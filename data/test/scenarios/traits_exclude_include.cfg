# wmllint: no translatables

#####
# API(s) being tested: exclude [trait] functionality
##
# Actions:
# Bob is told to generate special random traits.
##
# Expected end state:
# One of the two special traits excludes another trait to be already had by Bob.
# Bob should either not have the trait or have only the excluded one.
#####


#define TRAIT_TEST_REQUIRE
    # Test for require trait
    [trait]
        id=test_require
        male_name= _ "test_require"
        female_name= _ "female^test_require"
        help_text= _ "Test require"
        require_traits=test_required
        [effect]
            apply_to=hitpoints
            increase_total=1
        [/effect]
    [/trait]
#enddef

#define TRAIT_TEST_REQUIRED
    # Test for require trait
    [trait]
        id=test_required
        male_name= _ "test_required"
        female_name= _ "female^test_required"
        help_text= _ "Test required"
        [effect]
            apply_to=hitpoints
            increase_total=1
        [/effect]
    [/trait]
#enddef

#define TRAIT_TEST_EXCLUDE
    # Test for exclude trait
    [trait]
        id=test_exclude
        male_name= _ "test_exclude"
        female_name= _ "female^test_exclude"
        help_text= _ "Test exclude"
        exclude_traits=test_excluded,strong,quick,intelligent,resilient
        [effect]
            apply_to=hitpoints
            increase_total=1
        [/effect]
    [/trait]
#enddef

#define TRAIT_TEST_EXCLUDED
    # Test for require trait
    [trait]
        id=test_excluded
        male_name= _ "test_excluded"
        female_name= _ "female^test_excluded"
        help_text= _ "Test excluded"
        [effect]
            apply_to=hitpoints
            increase_total=1
        [/effect]
    [/trait]
#enddef

{GENERIC_UNIT_TEST "trait_exclusion_test" (
	[event]
		name=start
		{UNIT 1 (Test Unit Exclude) 1 1 (id=excluder1)}
	[/event]
	[event]
		name=side 1 turn 1
		[store_unit]
			[filter]
				side=1
				id=excluder1
			[/filter]
			variable=excluded
			kill=no
		[/store_unit]
		[if]
			# Check if the first randomly generated trait is the excluded one, then the
			# next trait slot should be empty
			{VARIABLE_CONDITIONAL excluded.modifications.trait[0].id equals "test_excluded"}
			[then]
				{ASSERT ({VARIABLE_CONDITIONAL excluded.modifications.trait[1].id equals $nil})}
			[/then]
			[else]
				# Otherwise if it is "test_exclude" then the next slot should be empty as well
				{ASSERT ({VARIABLE_CONDITIONAL excluded.modifications.trait[0].id equals "test_exclude"})}
				{ASSERT ({VARIABLE_CONDITIONAL excluded.modifications.trait[1].id equals $nil})}
			[/else]
		[/if]
		{SUCCEED}
	[/event]
)}

#####
# API(s) being tested: require [trait] functionality
##
# Actions:
# Bob is told to generate special random traits.
##
# Expected end state:
# One of the two special traits needs another trait to be already had by Bob.
# Bob only have the trait if it also has the one it requires one.
#####


{GENERIC_UNIT_TEST "trait_requirement_test" (
	[event]
		name=start
		{UNIT 1 (Test Unit Require) 1 1 (id=requirer1)}
	[/event]
	[event]
		name=side 1 turn 1
		[store_unit]
			[filter]
				side=1
				id=requirer1
			[/filter]
			variable=required
			kill=no
		[/store_unit]
		# Check if the second randomly generated trait is the one requiring the other one
		{ASSERT ({VARIABLE_CONDITIONAL required.modifications.trait[1].id equals "test_require"})}
		{SUCCEED}
	[/event]
)}
